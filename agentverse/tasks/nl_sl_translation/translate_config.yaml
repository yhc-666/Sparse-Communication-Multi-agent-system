task:
  translate
dataset:
  name: "ProofWriter" # ProntoQA # FOLIO
data_path:
  data/ProofWriter/dev.json
output_dir:
  outputs/translation/ProofWriter
prompts:
  # ${chat_history} 之前的放在system, 之后的放在user
  prompt: &prompt |-
    You are given a logic problem including a context and a question.
    Context: ${context}
    Question: ${question}
    ${role_description}
    
    Please translate this problem into First-Order Logic format.
    Return **only** Predicates, Premises, and Conclusion.

llm_config:
  # 模式选择: 'api' 使用API调用, 'local' 使用本地LLM
  mode: 'api'  # 可选: 'api' 或 'local'
  
  # API凭证配置
  api_credentials:
    openai_api_key: "sk-733e47bc35da4b49b0bc7ca99ede48f8"
    openai_base_url: "https://api.deepseek.com/v1"
  
  # API模式配置
  api_settings:
    model: "deepseek-chat"    # API调用的模型名称，直接传递给OpenAI兼容的API, 在 agentverse/llms/openai.py 中，通过 client.chat.completions.create(messages=messages, **self.args.dict()) 调用时，model 字段会被传递给API服务器
    llm_type: "gpt-4.1" #"deepseek-chat"  # LLM类选择：在 agentverse/initialization.py 的 load_llm() 函数中，通过 llm_registry.build(llm_type, **llm_config) 来选择具体的LLM实现类   注册系统：通过装饰器 @llm_registry.register() 将不同的LLM类注册到系统中
    temperature: 0
    max_tokens: 1250
    max_retry: 2


environment:
  env_type: llm_eval
  max_turns: 1    # Single turn for direct translation
  rule:
    order:
      type: concurrent # concurrent/sequential
    visibility:
      type: all
    selector:
      type: basic
    updater:
      type: basic
    describer:
      type: basic

agents:
  -
    agent_type: llm_eval_multi
    name: FOL translator
    final_prompt_to_use: |-
      Please ensure that the output format has no syntax error, such as unclosed parentheses, etc.
      Return **only** Predicates, Premises, and Conclusion.
      Do not add ID numbers such as 1., 2., etc.
    role_description: |-
       Task Description: Given a problem description and a question. The task is to parse the problem and the question into first-order logic formulas. The grammar of first-order logic is defined as follows:

        logical conjunction: expr1 ∧ expr2
        logical disjunction: expr1 ∨ expr2
        logical exclusive disjunction: expr1 ⊕ expr2
        logical negation: ¬expr1
        expr1 implies expr2: expr1 → expr2
        expr1 if and only if expr2: expr1 ↔ expr2
        logical universal quantification: ∀ x
        logical existential quantification: ∃ x
        Output format: logic form ::: description

        ---------------
        Example：
        Context: All people who regularly drink coffee are
        dependent on caffeine.
        (... more context here ...)
        If Rina is not a person dependent on caffeine and a
        student, then Rina is either a person dependent
        on caffeine and a student, or a person dependent
        on caffeine nor a student, or neither a person
        dependent on caffeine nor a student.

        Question: Based on the above information, is the
        following statement true, false, or uncertain?
        Rina is either a person who jokes about being
        addicted to caffeine or is unaware that caffeine
        is a drug.

        Predicates:
        Dependent(x) ::: x is a person dependent on caffeine
        (... more predicates here ...)
        Student(x) ::: x is a student

        Premises:
        ∀x (Drinks(x) → Dependent(x)) ::: All people who
        regularly drink coffee are dependent on caffeine.

        (... more premises here ...)
        ∀x (Jokes(x) → ¬Unaware(x)) ::: No one who jokes
        about being addicted to caffeine is unaware that
        caffeine is a drug.

        Conclusion:
        Jokes(rina) ⊕ Unaware(rina) ::: Rina is either a
        person who jokes about being addicted to caffeine
        or is unaware that caffeine is a drug.into a language that is understandable to the user.
    memory:
      memory_type: chat_history
    memory_manipulator:
      memory_manipulator_type: basic
    prompt_template: *prompt

tools: ~ 