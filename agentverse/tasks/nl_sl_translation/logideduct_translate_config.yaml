task:
  translate
dataset:
  name: "LogicalDeduction" #ProofWriter #ProntoQA #LogicalDeduction #FOLIO
data_path:
  data/LogicalDeduction/dev.json
output_dir:
  outputs/translation/LogicalDeduction
prompts:
  # ${chat_history} 之前的放在system, 之后的放在user
  prompt: &prompt |-
    You are given a logic problem including a context, question, and options.
    Context: ${context}
    Question: ${question}
    Options: ${options}
    ${role_description}
    
    Please translate this problem into First-Order Logic format.
    Return **only** Predicates, Premises, and Conclusion.

llm_config:
  mode: 'api' 

  api_credentials:
    openai_api_key: "sk-733e47bc35da4b49b0bc7ca99ede48f8"
    openai_base_url: "https://api.deepseek.com/v1"
  
  api_settings:
    model: "deepseek-chat"    # API调用的模型名称，直接传递给OpenAI兼容的API, 在 agentverse/llms/openai.py 中，通过 client.chat.completions.create(messages=messages, **self.args.dict()) 调用时，model 字段会被传递给API服务器
    llm_type: "deepseek-chat" #"deepseek-chat"  # LLM类选择：在 agentverse/initialization.py 的 load_llm() 函数中，通过 llm_registry.build(llm_type, **llm_config) 来选择具体的LLM实现类   注册系统：通过装饰器 @llm_registry.register() 将不同的LLM类注册到系统中
    temperature: 0
    max_tokens: 1250
    max_retry: 2

environment:
  env_type: llm_eval
  max_turns: 1    # Single turn for direct translation
  rule:
    order:
      type: concurrent # concurrent/sequential
    visibility:
      type: all
    selector:
      type: basic
    updater:
      type: basic
    describer:
      type: basic

agents:
  -
    agent_type: llm_eval_multi
    name: FOL translator
    final_prompt_to_use: |-
      Please ensure that the output format has no syntax error, such as unclosed parentheses, etc.
      Return **only** Predicates, Premises, and Conclusion.
    role_description: |-
       Task Description: Given a problem description and a question. The task is to parse the problem and the question into first-order logic formulas. The grammar of first-order logic is defined as follows:

        variable names: always use single/multi-character with underscores as variable names such as x, y, cow, blue_jay. Never use Dollar Sign Variables.
        logical conjunction: expr1 ∧ expr2
        logical disjunction: expr1 ∨ expr2
        logical exclusive disjunction: expr1 ⊕ expr2
        logical negation: ¬expr1
        expr1 implies expr2: expr1 → expr2
        expr1 if and only if expr2: expr1 ↔ expr2
        logical universal quantification: ∀ x
        logical existential quantification: ∃ x
        Output format: logic form ::: description

        ---------------
        Example：
        context: The following paragraphs each describe a set of five objects arranged in a fixed order. The statements are logically consistent within each paragraph.\n\nA fruit stand sells five fruits: mangoes, kiwis, plums, pears, and watermelons. The kiwis are less expensive than the plums. The pears are the third-most expensive. The kiwis are the second-cheapest. The watermelons are the most expensive.
        question: Which of the following is true?
        options: 
        A) The mangoes are the third-most expensive.
        B) The kiwis are the third-most expensive.
        C) The plums are the third-most expensive.
        D) The pears are the third-most expensive.
        E) The watermelons are the third-most expensive.

        Predicates:
        Rank(fruit, pos) ::: fruit has price position pos, where pos ∈ {one,two,three,four,five}; one = most expensive, five = cheapest.
        Cheaper(x, y) ::: x is cheaper (less expensive) than y.

        Premises:
        Rank(watermelon, one) :::Watermelons are the most expensive
        Rank(pears, three) ::: Pears are the third‑most expensive
        Rank(kiwis, four) ::: Kiwis are the second‑cheapest
        Cheaper(kiwis, plums) ::: Kiwis are cheaper than plums
        ∀F ∀P ∀Q ((Rank(F,P) ∧ Rank(F,Q)) → (P = Q)) ::: One rank per fruit
        ∀P ∀F ∀G ((Rank(F,P) ∧ Rank(G,P)) → (F = G)) ::: One fruit per rank
        Rank(mangoes, one) ∨ Rank(mangoes, two) ∨ Rank(mangoes, three) ∨ Rank(mangoes, four) ∨ Rank(mangoes, five) ::: each still‑unknown fruit occupies some rank 
        Rank(plums, one) ∨ Rank(plums, two) ∨ Rank(plums, three) ∨ Rank(plums, four) ∨ Rank(plums, five) ::: each still‑unknown fruit occupies some rank 
        ∀X ∀Y (Rank(X, one) ∧ Rank(Y, two) → Cheaper(Y, X)) ::: “higher rank → more expensive” (10 ordered pairs) 
        ∀X ∀Y (Rank(X, one) ∧ Rank(Y, three) → Cheaper(Y, X)) ::: “higher rank → more expensive” (10 ordered pairs) 
        ∀X ∀Y (Rank(X, one) ∧ Rank(Y, four) → Cheaper(Y, X)) ::: “higher rank → more expensive” (10 ordered pairs) 
        ∀X ∀Y (Rank(X, one) ∧ Rank(Y, five) → Cheaper(Y, X)) ::: “higher rank → more expensive” (10 ordered pairs) 
        ∀X ∀Y (Rank(X, two) ∧ Rank(Y, three) → Cheaper(Y, X)) ::: “higher rank → more expensive” (10 ordered pairs) 
        ∀X ∀Y (Rank(X, two) ∧ Rank(Y, four) → Cheaper(Y, X)) ::: “higher rank → more expensive” (10 ordered pairs) 
        ∀X ∀Y (Rank(X, two) ∧ Rank(Y, five) → Cheaper(Y, X)) ::: “higher rank → more expensive” (10 ordered pairs) 
        ∀X ∀Y (Rank(X, three) ∧ Rank(Y, four) → Cheaper(Y, X)) ::: “higher rank → more expensive” (10 ordered pairs) 
        ∀X ∀Y (Rank(X, three) ∧ Rank(Y, five) → Cheaper(Y, X)) ::: “higher rank → more expensive” (10 ordered pairs) 
        ∀X ∀Y (Rank(X, four) ∧ Rank(Y, five) → Cheaper(Y, X)) ::: “higher rank → more expensive” (10 ordered pairs) 
        ∀X ∀Y (Cheaper(X, Y) → ¬Cheaper(Y, X)) ::: “cheaper” is asymmetric

        Conclusion:
        Rank(mangoes, three) ::: Option A
        Rank(kiwis, three) ::: Option B
        Rank(plums, three) ::: Option C
        Rank(pears, three) ::: Option D
        Rank(watermelon, three) ::: Option E
        
    memory:
      memory_type: chat_history
    memory_manipulator:
      memory_manipulator_type: basic
    prompt_template: *prompt

tools: ~ 